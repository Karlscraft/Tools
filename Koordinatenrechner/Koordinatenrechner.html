<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karlscraft - Minecraft Koordinaten Karte</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
        }
        
        #map {
            height: 100vh;
            width: 100%;
            cursor: crosshair;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 350px;
            font-size: 14px;
        }
        
        .info-panel h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 20px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        
        .info-panel p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .info-panel strong {
            color: #2c3e50;
            display: inline-block;
            min-width: 140px;
        }
        
        .minecraft-coords {
            background: #27ae60;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            user-select: none;
        }
        
        .minecraft-coords:hover {
            background: #229954;
        }
        
        .minecraft-coords:active {
            background: #1e8449;
        }
        
        .copy-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
            font-weight: normal;
        }
        
        .copied-notification {
            background: #2ecc71;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: fadeInOut 2s;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        .real-coords {
            background: #3498db;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-top: 8px;
        }
        
        .warning {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .layer-control {
            position: absolute;
            top: 20px;
            left: 60px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        .layer-control h3 {
            margin-bottom: 10px;
            font-size: 16px;
            color: #2c3e50;
        }
        
        .layer-control label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
            color: #2c3e50;
        }
        
        .layer-control input {
            margin-right: 8px;
            cursor: pointer;
        }

        .elevation-loading {
            color: #95a5a6;
            font-style: italic;
        }

        .y-limit-exceeded {
            color: #e74c3c;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="layer-control">
        <h3>üó∫Ô∏è Kartenebenen</h3>
        <label>
            <input type="radio" name="layer" value="osm" checked>
            OpenStreetMap
        </label>
        <label>
            <input type="radio" name="layer" value="topo">
            OpenTopoMap
        </label>
        <label>
            <input type="radio" name="layer" value="railway">
            OpenRailwayMap
        </label>
    </div>
    
    <div class="info-panel" id="infoPanel">
        <h2>üéÆ Karlscraft Koordinaten</h2>
        <p>Klicke auf die Karte, um Minecraft-Koordinaten zu erhalten!</p>
        <p style="margin-top: 15px; color: #7f8c8d; font-size: 12px;">
            <strong>Nullpunkt:</strong> Pyramide am Marktplatz<br>
            <strong>Rotation:</strong> 4¬∞ f√ºr gerade Kaiserstra√üe<br>
            <strong>Ma√üstab:</strong> 1:1<br>
            <strong>Pr√§zision:</strong> Vincenty-Verfahren (¬±0,5mm)
        </p>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Nullpunkt: Pyramide am Marktplatz
        const ORIGIN_LAT = 49.00923;
        const ORIGIN_LON = 8.4039;
        const ORIGIN_ELEVATION = 115; // Meter √ºber NN
        const MINECRAFT_Y_ORIGIN = 64;
        const ROTATION_ANGLE = 4; // Grad Neigung f√ºr gerade Kaiserstra√üe
        
        // Initialisiere Karte
        const map = L.map('map').setView([ORIGIN_LAT, ORIGIN_LON], 15);
        
        // Layer definieren
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        });
        
        const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenTopoMap contributors',
            maxZoom: 17
        });
        
        const railwayLayer = L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
            attribution: '¬© OpenRailwayMap contributors',
            maxZoom: 19
        });
        
        // Standardlayer hinzuf√ºgen
        osmLayer.addTo(map);
        let currentLayer = osmLayer;
        
        // Layer-Steuerung
        document.querySelectorAll('input[name="layer"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                map.removeLayer(currentLayer);
                switch(e.target.value) {
                    case 'osm':
                        currentLayer = osmLayer;
                        break;
                    case 'topo':
                        currentLayer = topoLayer;
                        break;
                    case 'railway':
                        currentLayer = railwayLayer;
                        break;
                }
                currentLayer.addTo(map);
            });
        });
        
        // Marker f√ºr Nullpunkt
        const originMarker = L.marker([ORIGIN_LAT, ORIGIN_LON], {
            icon: L.divIcon({
                className: 'origin-marker',
                html: 'üî∫',
                iconSize: [30, 30],
                iconAnchor: [7, 10]
            })
        }).addTo(map);
        originMarker.bindPopup('<strong>Nullpunkt</strong><br>Pyramide am Marktplatz<br>MC: X:0, Y:64, Z:0');
        
        // Aktueller Marker
        let currentMarker = null;
        
        // WGS84 Ellipsoid-Parameter
        const WGS84 = {
            a: 6378137.0,           // Gro√üe Halbachse (√Ñquatorradius) in Metern
            b: 6356752.314245,      // Kleine Halbachse (Polradius) in Metern
            f: 1 / 298.257223563    // Abplattung
        };
        
        // Funktion: Vincenty-Formel f√ºr pr√§zise Distanzberechnung auf Ellipsoid
        function vincentyDistance(lat1, lon1, lat2, lon2) {
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const Œª1 = lon1 * Math.PI / 180;
            const Œª2 = lon2 * Math.PI / 180;
            
            const a = WGS84.a;
            const b = WGS84.b;
            const f = WGS84.f;
            
            const L = Œª2 - Œª1;
            const U1 = Math.atan((1 - f) * Math.tan(œÜ1));
            const U2 = Math.atan((1 - f) * Math.tan(œÜ2));
            const sinU1 = Math.sin(U1);
            const cosU1 = Math.cos(U1);
            const sinU2 = Math.sin(U2);
            const cosU2 = Math.cos(U2);
            
            let Œª = L;
            let ŒªPrev;
            let iterationLimit = 100;
            let cosSqŒ±, sinœÉ, cos2œÉM, cosœÉ, œÉ;
            
            do {
                const sinŒª = Math.sin(Œª);
                const cosŒª = Math.cos(Œª);
                const sinSqœÉ = (cosU2 * sinŒª) * (cosU2 * sinŒª) +
                              (cosU1 * sinU2 - sinU1 * cosU2 * cosŒª) *
                              (cosU1 * sinU2 - sinU1 * cosU2 * cosŒª);
                sinœÉ = Math.sqrt(sinSqœÉ);
                
                if (sinœÉ === 0) return 0; // Gleicher Punkt
                
                cosœÉ = sinU1 * sinU2 + cosU1 * cosU2 * cosŒª;
                œÉ = Math.atan2(sinœÉ, cosœÉ);
                const sinŒ± = cosU1 * cosU2 * sinŒª / sinœÉ;
                cosSqŒ± = 1 - sinŒ± * sinŒ±;
                cos2œÉM = cosœÉ - 2 * sinU1 * sinU2 / cosSqŒ±;
                
                if (isNaN(cos2œÉM)) cos2œÉM = 0; // √Ñquatoriale Linie
                
                const C = f / 16 * cosSqŒ± * (4 + f * (4 - 3 * cosSqŒ±));
                ŒªPrev = Œª;
                Œª = L + (1 - C) * f * sinŒ± *
                    (œÉ + C * sinœÉ * (cos2œÉM + C * cosœÉ * (-1 + 2 * cos2œÉM * cos2œÉM)));
                    
            } while (Math.abs(Œª - ŒªPrev) > 1e-12 && --iterationLimit > 0);
            
            if (iterationLimit === 0) {
                // Fallback auf einfachere Formel bei Nicht-Konvergenz
                return null;
            }
            
            const uSq = cosSqŒ± * (a * a - b * b) / (b * b);
            const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
            const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
            const ŒîœÉ = B * sinœÉ * (cos2œÉM + B / 4 * (cosœÉ * (-1 + 2 * cos2œÉM * cos2œÉM) -
                      B / 6 * cos2œÉM * (-3 + 4 * sinœÉ * sinœÉ) * (-3 + 4 * cos2œÉM * cos2œÉM)));
            
            const distance = b * A * (œÉ - ŒîœÉ);
            
            return distance;
        }
        
        // Funktion: Vincenty-Formel f√ºr pr√§zisen Richtungswinkel (Azimuth)
        function vincentyBearing(lat1, lon1, lat2, lon2) {
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const Œª1 = lon1 * Math.PI / 180;
            const Œª2 = lon2 * Math.PI / 180;
            
            const a = WGS84.a;
            const b = WGS84.b;
            const f = WGS84.f;
            
            const L = Œª2 - Œª1;
            const U1 = Math.atan((1 - f) * Math.tan(œÜ1));
            const U2 = Math.atan((1 - f) * Math.tan(œÜ2));
            const sinU1 = Math.sin(U1);
            const cosU1 = Math.cos(U1);
            const sinU2 = Math.sin(U2);
            const cosU2 = Math.cos(U2);
            
            let Œª = L;
            let ŒªPrev;
            let iterationLimit = 100;
            let sinŒª, cosŒª, sinœÉ, cosœÉ, œÉ, sinŒ±, cosSqŒ±, cos2œÉM;
            
            do {
                sinŒª = Math.sin(Œª);
                cosŒª = Math.cos(Œª);
                const sinSqœÉ = (cosU2 * sinŒª) * (cosU2 * sinŒª) +
                              (cosU1 * sinU2 - sinU1 * cosU2 * cosŒª) *
                              (cosU1 * sinU2 - sinU1 * cosU2 * cosŒª);
                sinœÉ = Math.sqrt(sinSqœÉ);
                
                if (sinœÉ === 0) return 0;
                
                cosœÉ = sinU1 * sinU2 + cosU1 * cosU2 * cosŒª;
                œÉ = Math.atan2(sinœÉ, cosœÉ);
                sinŒ± = cosU1 * cosU2 * sinŒª / sinœÉ;
                cosSqŒ± = 1 - sinŒ± * sinŒ±;
                cos2œÉM = cosœÉ - 2 * sinU1 * sinU2 / cosSqŒ±;
                
                if (isNaN(cos2œÉM)) cos2œÉM = 0;
                
                const C = f / 16 * cosSqŒ± * (4 + f * (4 - 3 * cosSqŒ±));
                ŒªPrev = Œª;
                Œª = L + (1 - C) * f * sinŒ± *
                    (œÉ + C * sinœÉ * (cos2œÉM + C * cosœÉ * (-1 + 2 * cos2œÉM * cos2œÉM)));
                    
            } while (Math.abs(Œª - ŒªPrev) > 1e-12 && --iterationLimit > 0);
            
            if (iterationLimit === 0) return null;
            
            // Forward azimuth (Richtungswinkel)
            const Œ±1 = Math.atan2(cosU2 * sinŒª, cosU1 * sinU2 - sinU1 * cosU2 * cosŒª);
            
            return (Œ±1 * 180 / Math.PI + 360) % 360;
        }
        
        // Funktion: H√∂he von Open-Elevation API abrufen
        async function getElevation(lat, lon) {
            try {
                const response = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    return data.results[0].elevation;
                }
            } catch (error) {
                console.error('Fehler beim Abrufen der H√∂he:', error);
            }
            return null;
        }
        
        // Funktion: Koordinaten zu Minecraft umrechnen
        async function convertToMinecraft(lat, lon) {
            // Distanz zum Nullpunkt mit Vincenty (pr√§zise auf Ellipsoid)
            const distance = vincentyDistance(ORIGIN_LAT, ORIGIN_LON, lat, lon);
            
            // Fallback falls Vincenty nicht konvergiert
            if (distance === null) {
                return {
                    x: null,
                    y: null,
                    z: null,
                    elevation: null,
                    error: true
                };
            }
            
            // Richtung vom Nullpunkt zum Punkt mit Vincenty
            const bearing = vincentyBearing(ORIGIN_LAT, ORIGIN_LON, lat, lon);
            
            if (bearing === null) {
                return {
                    x: null,
                    y: null,
                    z: null,
                    elevation: null,
                    error: true
                };
            }
            
            // Rotation um 4¬∞ anwenden (damit Kaiserstra√üe gerade wird)
            const adjustedBearing = (bearing - ROTATION_ANGLE + 360) % 360;
            
            // In Minecraft-Koordinaten umrechnen
            // Norden = 0¬∞, Osten = 90¬∞, S√ºden = 180¬∞, Westen = 270¬∞
            // In Minecraft: +X = Osten, -X = Westen, -Z = Norden, +Z = S√ºden
            const angleRad = adjustedBearing * Math.PI / 180;
            
            const minecraftX = Math.round(distance * Math.sin(angleRad));
            const minecraftZ = Math.round(-distance * Math.cos(angleRad));
            
            // H√∂he abrufen
            const elevation = await getElevation(lat, lon);
            let minecraftY = null;
            if (elevation !== null) {
                minecraftY = Math.round(MINECRAFT_Y_ORIGIN + (elevation - ORIGIN_ELEVATION));
            }
            
            return {
                x: minecraftX,
                y: minecraftY,
                z: minecraftZ,
                elevation: elevation,
                error: false
            };
        }
        
        // Karten-Klick Event
        map.on('click', async function(e) {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            // Alten Marker entfernen
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }
            
            // Neuen Marker setzen
            currentMarker = L.marker([lat, lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            // Info-Panel mit Ladehinweis aktualisieren
            const infoPanel = document.getElementById('infoPanel');
            infoPanel.innerHTML = `
                <h2>üéÆ Karlscraft Koordinaten</h2>
                <div class="real-coords">
                    <strong>üìç Echte Koordinaten:</strong><br>
                    Breite: ${lat.toFixed(6)}¬∞<br>
                    L√§nge: ${lon.toFixed(6)}¬∞<br>
                    H√∂he: <span class="elevation-loading">Wird geladen...</span>
                </div>
                <div class="minecraft-coords">
                    <strong>‚õèÔ∏è Minecraft Koordinaten:</strong><br>
                    Berechne...
                </div>
            `;
            
            // Minecraft-Koordinaten berechnen
            const mc = await convertToMinecraft(lat, lon);
            
            // Fehlerbehandlung falls Vincenty fehlschl√§gt
            if (mc.error) {
                infoPanel.innerHTML = `
                    <h2>üéÆ Karlscraft Koordinaten</h2>
                    <div class="warning">
                        ‚ö†Ô∏è Fehler bei der Berechnung!<br>
                        Bitte versuche einen anderen Punkt.
                    </div>
                `;
                return;
            }
            
            // Info-Panel aktualisieren
            let elevationText = mc.elevation !== null ? `${mc.elevation.toFixed(1)} m` : 'Nicht verf√ºgbar';
            let yText = mc.y !== null ? `${mc.y}` : 'Nicht verf√ºgbar';
            let yClass = '';
            let warning = '';
            
            if (mc.y !== null && mc.y > 255) {
                yClass = 'y-limit-exceeded';
                warning = '<div class="warning">‚ö†Ô∏è WARNUNG: Y-Koordinate √ºber 255!<br>Baulimit √ºberschritten!</div>';
            }
            
            infoPanel.innerHTML = `
                <h2>üéÆ Karlscraft Koordinaten</h2>
                <div class="real-coords">
                    <strong>üìç Echte Koordinaten:</strong><br>
                    Breite: ${lat.toFixed(6)}¬∞<br>
                    L√§nge: ${lon.toFixed(6)}¬∞<br>
                    H√∂he: ${elevationText} √ºber NN
                </div>
                <div class="minecraft-coords" id="mcCoords" data-x="${mc.x}" data-y="${mc.y}" data-z="${mc.z}">
                    <strong>‚õèÔ∏è Minecraft Koordinaten:</strong><br>
                    X: ${mc.x}<br>
                    Y: <span class="${yClass}">${yText}</span><br>
                    Z: ${mc.z}
                    <div class="copy-hint">üìã Rechtsklick zum Kopieren</div>
                </div>
                ${warning}
                <p style="margin-top: 15px; color: #7f8c8d; font-size: 12px;">
                    <strong>Distanz vom Nullpunkt:</strong><br>
                    ${Math.round(Math.sqrt(mc.x*mc.x + mc.z*mc.z))} Bl√∂cke<br>
                    <em style="color: #27ae60;">‚úì Vincenty-Pr√§zision (¬±0,5mm)</em>
                </p>
            `;
            
            // Event-Listener f√ºr Rechtsklick zum Kopieren
            const mcCoordsDiv = document.getElementById('mcCoords');
            if (mcCoordsDiv) {
                mcCoordsDiv.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    
                    const x = this.dataset.x;
                    const y = this.dataset.y;
                    const z = this.dataset.z;
                    
                    const coordText = `[x:${x}, y:${y}, z:${z}]`;
                    
                    // In Zwischenablage kopieren
                    navigator.clipboard.writeText(coordText).then(() => {
                        // Erfolgsmeldung anzeigen
                        const notification = document.createElement('div');
                        notification.className = 'copied-notification';
                        notification.textContent = '‚úì Koordinaten kopiert!';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            notification.remove();
                        }, 2000);
                    }).catch(err => {
                        console.error('Fehler beim Kopieren:', err);
                        alert('Fehler beim Kopieren in die Zwischenablage');
                    });
                });
            }
        });
    </script>
</body>
</html>
